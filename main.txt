from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
import hashlib

app = FastAPI()

# Models
class User(BaseModel):
    email: str
    password: str

class PriceAnalysisRequest(BaseModel):
    current_price: float
    predicted_price: float
    competitor_price: float
    actual_cost: float

# Simple password hashing
def hash_password(password: str) -> str:
    return hashlib.md5(password.encode()).hexdigest()

# Simple storage (in memory)
users = []
analyses = []

# Health check
@app.get("/health")
def health_check():
    return {"status": "ok", "timestamp": datetime.now().isoformat()}

# Sign up
@app.post("/signup")
def signup(user: User):
    # Check if user exists
    for u in users:
        if u["email"] == user.email:
            raise HTTPException(status_code=400, detail="Email already exists")
    
    # Add user
    user_data = {
        "id": len(users) + 1,
        "email": user.email,
        "password": hash_password(user.password),
        "created_at": datetime.now()
    }
    users.append(user_data)
    return {"id": user_data["id"], "email": user.email, "message": "User created"}

# Login
@app.post("/login")
def login(user: User):
    for u in users:
        if u["email"] == user.email and u["password"] == hash_password(user.password):
            return {"message": "Login successful", "email": user.email}
    raise HTTPException(status_code=400, detail="Invalid credentials")

# Analyze price
@app.post("/analyze-price")
def analyze_price(request: PriceAnalysisRequest):
    # Simple calculation
    recommended_price = (request.current_price + request.competitor_price) / 2
    
    # Ensure it's above cost
    if recommended_price < request.actual_cost:
        recommended_price = request.actual_cost * 1.2
    
    analysis_data = {
        "id": len(analyses) + 1,
        "current_price": request.current_price,
        "competitor_price": request.competitor_price,
        "actual_cost": request.actual_cost,
        "recommended_price": round(recommended_price, 2),
        "analysis": f"Recommended price: {recommended_price:.2f} based on market average",
        "timestamp": datetime.now()
    }
    analyses.append(analysis_data)
    
    return analysis_data

# Get analysis history
@app.get("/analysis-history")
def get_analysis_history():
    return analyses

# Root
@app.get("/")
def root():
    return {"message": "API is running"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)